#include "CodeGen.h"



namespace omegasl {

    const char defaultHeaders[] = R"(// Warning! This file was generated by omegaslc
#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

)";

    #ifdef TARGET_METAL
        void compileMTLShader(void *mtl_device,unsigned length,const char *string,void **pDest);
    #endif

    class MetalCodeGen : public CodeGen {

        std::ostringstream stringOut;
        std::ofstream fileOut;

        std::ostream & shaderOut;

        std::map<std::string,std::string> generatedFuncs;
        std::map<std::string,std::string> generatedStructs;

        MetalCodeOpts & metalCodeOpts;

    public:
        explicit MetalCodeGen(CodeGenOpts &opts,MetalCodeOpts & metalCodeOpts):
        CodeGen(opts),shaderOut(fileOut),metalCodeOpts(metalCodeOpts){

        }
        explicit MetalCodeGen(CodeGenOpts &opts,MetalCodeOpts & metalCodeOpts,std::ostringstream & stringOut):
                CodeGen(opts), stringOut(std::move(stringOut)),shaderOut(this->stringOut),metalCodeOpts(metalCodeOpts){

        }
        inline void writeTypeExpr(ast::TypeExpr *t,std::ostream & out){
            using namespace ast;
            auto * _t = typeResolver->resolveTypeWithExpr(t);

            if(_t == builtins::void_type){
                out << "void";
            }
            else if(_t == builtins::int_type){
                out << "int";
            }
            else if(_t == builtins::uint_type){
                out << "uint";
            }
            else if(_t == builtins::uint2_type){
                out << "simd_uint2";
            }
            else if(_t == builtins::uint3_type){
                out << "simd_uint3";
            }
            else if(_t == builtins::float_type){
                out << "simd_float";
            }
            else if(_t == builtins::float2_type){
                out << "simd_float2";
            }
            else if(_t == builtins::float3_type){
                out << "simd_float3";
            }
            else if(_t == builtins::float4_type){
                out << "simd_float4";
            }
            else if(_t == builtins::sampler2d_type || _t == builtins::sampler3d_type){
                out << "sampler";
            }
            else {
                out << t->name;
            }


            if(t->pointer){
                out << " *";
            }
        }
        inline void writeAttributeName(OmegaCommon::StrRef attributeName,std::ostream & out){
            if(attributeName == ATTRIBUTE_POSITION){
                out << "position";
            }
            else if(attributeName == ATTRIBUTE_VERTEX_ID){
                out << "vertex_id";
            }
            else if(attributeName == ATTRIBUTE_INSTANCE_ID){
                out << "instance_id";
            }
            else if(attributeName == ATTRIBUTE_GLOBALTHREAD_ID){
                out << "thread_position_in_grid";
            }
            else if(attributeName == ATTRIBUTE_THREADGROUP_ID){
                out << "threadgroup_position_in_grid";
            }
            else if(attributeName == ATTRIBUTE_LOCALTHREAD_ID){
                out << "thread_position_in_threadgroup";
            }
        }
        void generateExpr(ast::Expr *expr) override {
            switch (expr->type) {
                case ID_EXPR : {
                    auto _expr = (ast::IdExpr *)expr;
                    shaderOut << _expr->id;
                    break;
                }
                case BINARY_EXPR : {
                    auto _expr = (ast::BinaryExpr *)expr;
                    generateExpr(_expr->lhs);
                    shaderOut << " " << _expr->op << " ";
                    generateExpr(_expr->rhs);
                    break;
                }
                case MEMBER_EXPR : {
                    auto _expr = (ast::MemberExpr *)expr;
                    generateExpr(_expr->lhs);
                    shaderOut << "." << _expr->rhs_id;
                    break;
                }
                case INDEX_EXPR : {
                    auto _expr = (ast::IndexExpr *)expr;
                    generateExpr(_expr->lhs);
                    shaderOut << "[";
                    generateExpr(_expr->idx_expr);
                    shaderOut << "]";
                    break;
                }
                case CALL_EXPR : {
                    auto _expr = (ast::CallExpr *)expr;
                    OmegaCommon::StrRef func_name = ((ast::IdExpr *)_expr->callee)->id;

                    bool generated = false;

                    if(func_name == BUILTIN_MAKE_FLOAT2){
                        shaderOut << "simd_make_float2";
                    }
                    else if(func_name == BUILTIN_MAKE_FLOAT3){
                        shaderOut << "simd_make_float3";
                    }
                    else if(func_name == BUILTIN_MAKE_FLOAT4){
                        shaderOut << "simd_make_float4";
                    }
                    else if(func_name == BUILTIN_SAMPLE){
                        generated = true;
                        generateExpr(_expr->args[1]);
                        shaderOut << ".sample";
                        shaderOut << "(";
                        generateExpr(_expr->args[0]);
                        shaderOut << ",";
                        generateExpr(_expr->args[2]);
                        shaderOut << ")";
                    }
                    else if(func_name == BUILTIN_WRITE){
                        generated = true;
                        generateExpr(_expr->args[0]);
                        shaderOut << ".write";
                        shaderOut << "(";
                        generateExpr(_expr->args[1]);
                        shaderOut << ")";
                    }

                    if(!generated){
                        shaderOut << "(";
                        for(auto a_it = _expr->args.begin();a_it != _expr->args.end();a_it++){
                            if(a_it != _expr->args.begin()){
                                shaderOut << ",";
                            }
                            generateExpr(*a_it);
                        }
                        shaderOut << ")";
                    }

                    break;
                }
            }
        }
    private:
        unsigned level_count;
        bool shaderDecl = false;
    public:
        void generateBlock(ast::Block &block) override {

            for(unsigned l = level_count;l != 0;l--){
                shaderOut << "    ";
            }
            if(shaderDecl) {
                shaderDecl = false;
            }
            else {
                shaderOut << "{" << std::endl;
            }
            ++level_count;

            for(auto stmt : block.body){
                for(unsigned l = level_count;l != 0;l--){
                    shaderOut << "    ";
                }
                if(stmt->type == VAR_DECL || stmt->type == RETURN_DECL){
                    generateDecl((ast::Decl *)stmt);
                    shaderOut << ";" << std::endl;
                }
                else {
                    generateExpr((ast::Expr *)stmt);
                    shaderOut << ";" << std::endl;
                }
            }

            --level_count;
            shaderOut << "}" << std::endl;
        }
        void generateDecl(ast::Decl *decl) override {
            switch (decl->type) {
                case VAR_DECL : {
                    auto *_decl = (ast::VarDecl *)decl;
                    writeTypeExpr(_decl->typeExpr,shaderOut);
                    shaderOut << " " << _decl->spec.name;
                    if(_decl->spec.initializer.has_value()){
                        shaderOut << " = ";
                        generateExpr(_decl->spec.initializer.value());
                    }
                    break;
                }
                case RETURN_DECL : {
                    auto *_decl = (ast::ReturnDecl *)decl;
                    shaderOut << "return ";
                    generateExpr(_decl->expr);
                    break;
                }
                case RESOURCE_DECL : {
                    auto *_decl = (ast::ResourceDecl *)decl;
                    resourceStore.add(_decl);
                    break;
                }
                case STRUCT_DECL : {
                    auto *_decl = (ast::StructDecl *)decl;
                    std::ostringstream out;
                    out << "struct " << _decl->name << " {" << std::endl;
                    for(auto p : _decl->fields){
                        out << "    ";
                        writeTypeExpr(p.typeExpr,out);
                        out << " " << p.name;
                        if(p.attributeName.has_value()){
                            if(p.attributeName != ATTRIBUTE_COLOR && p.attributeName != ATTRIBUTE_TEXCOORD){
                                out << "[[";
                                writeAttributeName(p.attributeName.value(),out);
                                out << "]]";
                            }
                        }
                        out << ";" << std::endl;
                    }
                    out << "};" << std::endl;

                    generatedStructs.insert(std::make_pair(_decl->name,out.str()));
                    break;
                }
                case SHADER_DECL : {
                    shaderDecl = true;
                    level_count = 0;
                    auto *_decl = (ast::ShaderDecl *)decl;
                    OmegaCommon::String object_file;

                    if(opts.runtimeCompile){
                        object_file = _decl->name;
                        stringOut.str("");
                    }
                    else {
                        object_file =  OmegaCommon::FS::Path(opts.tempDir).append(_decl->name).concat(".metallib").str();
                        fileOut.open(OmegaCommon::FS::Path(opts.tempDir).append(_decl->name).concat(".metal").str(),
                                     std::ios::out);
                    }

                    shaderOut << defaultHeaders;

                    std::vector<std::string> used_type_list;
                    typeResolver->getStructsInFuncDecl(_decl,used_type_list);

                    if(!used_type_list.empty()){
                        for(auto & t : used_type_list){
                            shaderOut << generatedStructs[t] << std::endl << std::endl;
                        }
                    }

                    omegasl_shader shadermap_entry {};
                    shadermap_entry.name = new char[_decl->name.size() + 1];
                    std::copy(_decl->name.begin(),_decl->name.end(),(char *)shadermap_entry.name);
                    ((char *)shadermap_entry.name)[_decl->name.size()] = '\0';


                    if(_decl->shaderType == ast::ShaderDecl::Vertex){
                        shaderOut << "vertex";
                        shadermap_entry.type = OMEGASL_SHADER_VERTEX;
                    }
                    else if(_decl->shaderType == ast::ShaderDecl::Fragment){
                        shaderOut << "fragment";
                        shadermap_entry.type = OMEGASL_SHADER_FRAGMENT;
                    }
                    else if(_decl->shaderType == ast::ShaderDecl::Compute){
                        shaderOut << "kernel";
                        shadermap_entry.type = OMEGASL_SHADER_COMPUTE;
                        shadermap_entry.threadgroupDesc.x = _decl->threadgroupDesc.x;
                        shadermap_entry.threadgroupDesc.y = _decl->threadgroupDesc.y;
                        shadermap_entry.threadgroupDesc.z = _decl->threadgroupDesc.z;
                    }

                    shaderOut << " ";
                    writeTypeExpr(_decl->returnType,shaderOut);
                    shaderOut << " " << _decl->name << " ";
                    shaderOut << "(";

                    OmegaCommon::Vector<omegasl_shader_layout_desc> shaderLayout;

                    OmegaCommon::Vector<OmegaCommon::String> staticSamplers;

                    unsigned i = 0,bufferCount = 0,textureCount = 0,samplerCount = 0;
                    for(auto & res : _decl->resourceMap){

                        omegasl_shader_layout_desc_type layoutDescType;
                        omegasl_shader_layout_desc_io_mode  ioMode;



                        auto & res_desc = *(resourceStore.find(res.name));
                        auto type_ = typeResolver->resolveTypeWithExpr(res_desc->typeExpr);

                        if(i != 0 && !(res_desc->isStatic)){
                            shaderOut << ",";
                        }

                        if(type_ == ast::builtins::buffer_type) {

                            if (res.access == ast::ShaderDecl::ResourceMapDesc::In) {
                                shaderOut << "constant ";
                                ioMode = OMEGASL_SHADER_DESC_IO_IN;
                            } else if (res.access == ast::ShaderDecl::ResourceMapDesc::Inout) {
                                shaderOut << "device ";
                                ioMode = OMEGASL_SHADER_DESC_IO_INOUT;
                            } else {
                                shaderOut << "device ";
                                ioMode = OMEGASL_SHADER_DESC_IO_OUT;
                            }

                        }

                        bool isTexture = false,isBuffer = false,isSampler = false;

                        auto writeSampler = [&](){
                            std::ostringstream out;
                            out << "constexpr sampler " << res_desc->name << " = sampler(filter::";
                            /// 1. Write Filter Mode
                            switch (res_desc->staticSamplerDesc->filter) {
                                case OMEGASL_SHADER_SAMPLER_LINEAR_FILTER : {
                                    out << "linear";
                                    break;
                                }
                                case OMEGASL_SHADER_SAMPLER_POINT_FILTER : {
                                    out << "nearest";
                                    break;
                                }
                            }

                            out << ",address::";

                            /// 2. Write Address Mode

                            switch(res_desc->staticSamplerDesc->uAddressMode){
                                case OMEGASL_SHADER_SAMPLER_ADDRESS_MODE_WRAP : {
                                    out << "repeat";
                                    break;
                                }
                                case OMEGASL_SHADER_SAMPLER_ADDRESS_MODE_MIRROR : {
                                    out << "mirror";
                                }
                            }

                            out << ");" << std::endl;
                            staticSamplers.push_back(out.str());
                        };

                        if(type_ == ast::builtins::buffer_type){
                            isBuffer = true;
                            writeTypeExpr(res_desc->typeExpr->args[0],shaderOut);
                            shaderOut << " *";
                            layoutDescType = OMEGASL_SHADER_BUFFER_DESC;
                        }
                        else if(type_ == ast::builtins::texture1d_type){
                            isTexture = true;
                            shaderOut << "texture1d<float,";
                            layoutDescType = OMEGASL_SHADER_TEXTURE1D_DESC;
                        }
                        else if(type_ == ast::builtins::texture2d_type){
                            isTexture = true;
                            shaderOut << "texture2d<float,";
                            layoutDescType = OMEGASL_SHADER_TEXTURE2D_DESC;
                        }
                        else if(type_ == ast::builtins::texture3d_type){
                            isTexture = true;
                            shaderOut << "texture3d<float,";
                            layoutDescType = OMEGASL_SHADER_TEXTURE3D_DESC;
                        }
                        else if(type_ == ast::builtins::sampler2d_type){
                            isSampler = true;
                            if(res_desc->isStatic){
                                layoutDescType = OMEGASL_SHADER_STATIC_SAMPLER2D_DESC;
                                writeSampler();
                            }
                            else {
                                layoutDescType = OMEGASL_SHADER_SAMPLER2D_DESC;
                            }
                        }
                        else if(type_ == ast::builtins::sampler3d_type){
                            isSampler = true;
                            if(res_desc->isStatic){
                                layoutDescType = OMEGASL_SHADER_STATIC_SAMPLER3D_DESC;
                                writeSampler();
                            }
                            else {
                                shaderOut << "sampler";
                                layoutDescType = OMEGASL_SHADER_SAMPLER3D_DESC;
                            }
                            continue;
                        }

                        if(isTexture){
                            if(res.access == ast::ShaderDecl::ResourceMapDesc::In){
                                shaderOut << "access::sample>";
                            }
                            else if(res.access == ast::ShaderDecl::ResourceMapDesc::Inout){
                                shaderOut << "access::readwrite>";
                            }
                            else {
                                shaderOut << "access::write>";
                            }
                        }

                        if(!res_desc->isStatic) {
                            shaderOut << " " << res_desc->name;
                        }

                        unsigned *binding;

                        if(isTexture){
                            binding = &textureCount;
                        }
                        else if(isBuffer){
                            binding = &bufferCount;
                        }
                        else if(isSampler){
                            binding = &samplerCount;
                        }

                        shaderLayout.push_back({layoutDescType,*binding,ioMode,res_desc->registerNumber});


                        if(isTexture){
                            shaderOut << "[[texture(" << textureCount;
                            ++textureCount;
                            shaderOut << ")]]";
                        }
                        else if(isBuffer){
                            shaderOut << "[[buffer(" << bufferCount;
                            ++bufferCount;
                            shaderOut << ")]]";
                        }
                        else if(isSampler && !(res_desc->isStatic)){
                            shaderOut << "[[sampler(" << samplerCount;
                            ++samplerCount;
                            shaderOut << ")]]";
                        }
                        i++;
                    }

                    shadermap_entry.nLayout = shaderLayout.size();
                    if(!shaderLayout.empty()){
                        shadermap_entry.pLayout = new omegasl_shader_layout_desc[shaderLayout.size()];
                        std::copy(shaderLayout.begin(),shaderLayout.end(),shadermap_entry.pLayout);
                    }

                    shaderLayout.clear();

                    if(!(_decl->params.empty()) && !(_decl->resourceMap.empty())){
                        shaderOut << ",";
                    }

                    for(auto p_it =  _decl->params.begin();p_it != _decl->params.end();p_it++){

                        if(p_it != _decl->params.begin()) {
                            shaderOut << ",";
                        }

                        auto & p = *p_it;

                        writeTypeExpr(p.typeExpr,shaderOut);
                        shaderOut << " " << p.name << " ";

                        if(_decl->shaderType == ast::ShaderDecl::Fragment){
                            shaderOut << "[[stage_in]]";
                        }

                        if(p.attributeName.has_value()){
                            if(p.attributeName.value() == ATTRIBUTE_VERTEX_ID){
                                shadermap_entry.vertexShaderInputDesc.useVertexID = true;
                            }
                            else if(p.attributeName.value() == ATTRIBUTE_GLOBALTHREAD_ID){
                                shadermap_entry.computeShaderParamsDesc.useGlobalThreadID = true;
                            }
                            else if(p.attributeName.value() == ATTRIBUTE_THREADGROUP_ID){
                                shadermap_entry.computeShaderParamsDesc.useThreadGroupID = true;
                            }
                            shaderOut << "[[";
                            writeAttributeName(p.attributeName.value(),shaderOut);
                            shaderOut << "]]";
                        }
                    }
                    shaderOut << "){" << std::endl;

                    for(auto & ss : staticSamplers){
                        shaderOut << ss;
                    }
                    shaderOut << std::endl;

                    shaderMap.insert(std::make_pair(object_file,shadermap_entry));

                    generateBlock(*_decl->block);

                    if(opts.runtimeCompile){

                    }
                    else {
                        fileOut.close();
                    }
                    break;
                }
                default : {
                    break;
                }
            }
        }
        void compileShader(ast::ShaderDecl::Type type, const OmegaCommon::StrRef &name, const OmegaCommon::FS::Path &path,const OmegaCommon::FS::Path & outputPath) override {

            auto object_file =OmegaCommon::FS::Path(outputPath).append(name).concat(".metallib").str() ;

            std::ostringstream out;
            out << "  -o " << object_file.c_str() << " " << OmegaCommon::FS::Path(path).append(name).concat(".metal").absPath();

            auto metal_process = OmegaCommon::ChildProcess::OpenWithStdoutPipe(metalCodeOpts.metal_cmd,out.str().c_str());
            auto res = metal_process.wait();


        }
        void compileShaderOnRuntime(ast::ShaderDecl::Type type,const OmegaCommon::StrRef &name) override {
            #ifdef TARGET_METAL
            auto source = stringOut.str();
                if(metalCodeOpts.mtl_device != nullptr){
                    auto & _m = shaderMap[name.data()];
                    compileMTLShader(metalCodeOpts.mtl_device,source.size(),source.data(), &_m.data);
                }
            #endif
        }
    };

    std::shared_ptr<CodeGen> MetalCodeGenMake(CodeGenOpts &opts,MetalCodeOpts &metalCodeOpts){
        return std::make_shared<MetalCodeGen>(opts,metalCodeOpts);
    };

    std::shared_ptr<CodeGen> MetalCodeGenMakeRuntime(CodeGenOpts &opts,MetalCodeOpts &metalCodeOpts,std::ostringstream & out){
        return std::make_shared<MetalCodeGen>(opts,metalCodeOpts,out);
    };
}
